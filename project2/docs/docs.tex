% Author: Daniel Detore
% remind me to stop using this god-forsaken language.

\documentclass[12pt, oneside]{memoir}
\usepackage[firstpageonly=true]{draftwatermark}
\usepackage{indentfirst}
\usepackage[charter]{mathdesign}
\usepackage[T1]{fontenc}
\usepackage{epigraph}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{calc}
\usepackage{enumitem}
\usepackage{float}
\usepackage{hyperref}

\setlength{\beforechapskip}{0em}
\setlength{\afterchapskip}{2em}
\setlength{\baselineskip}{1em}
\setlength{\topskip}{0em}

\setlrmarginsandblock{1in}{1in}{*}
\setulmarginsandblock{1in}{1in}{*}
\checkandfixthelayout

%\renewcommand{\chaptername}{Section}
\renewcommand{\afterchapternum}{:\quad}

\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\definecolor{register}{HTML}{E33318}
\newcommand{\R}[1]{{\color{register}\texttt{R#1}}}

\definecolor{imm}{HTML}{DA108E}
\newcommand{\imm}{{\color{imm}\texttt{imm8}}}

\definecolor{instruction}{HTML}{1D8991}
\newcommand{\instruction}[1]{{\color{instruction}\texttt{#1}}}

\definecolor{header}{HTML}{8A31B9}
\newcommand{\header}[1]{{\color{header}\texttt{#1}}}

\title{
    {\HUGE\bfseries HANDv8 and the Sqrtr for Dummies}\\
    {\large\bfseries 1st Edition}\linebreak\linebreak
    {\large\textit{A Once-In-A-Lifetime Guide to}}\\
    {\Large Understanding My Revolutionary Contribution\\to the Field of Computer Science}\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak\linebreak
}
\author{
    {\Large Daniel Detore}, ddetore@stevens.edu\\
    CS 382-D\\
    Professor Shudong Hao\\
    {\small I pledge my honor that I have abided by the Stevens Honor System.}\\
}

\AtBeginDocument{\raggedright}

\begin{document}

\frontmatter
\maketitle
\thispagestyle{empty}
\newpage

\epigraph{There is no reason for any individual to have a computer in his home.}{\textit{- Ken Olsen}}
\tableofcontents
\newpage
%\listoffigures
%\newpage
%\listoftables
%\newpage

\setlength{\parindent}{1.5em}
\setlength{\parskip}{1em}

\chapter{Author's Note}
I am a computer scientist. I am neither an electrical engineer nor a mathematician. Anyone with meaningful knowledge of these fields (including computer science) will, in all likelihood, be vexed and enraged by my decisions herein. Please direct any complaints to your local recycling center. Questions or wellness checks can be sent to my email on the cover page.

This manual is dedicated to my parents, who are alive but would be instantly sent into cardiac arrest if I tried explaining any of this technology to them.

\mainmatter
\chapter{The Sqrtr}
Let's get this out of the way so we can get to work:
\section{What's with the name?}
My mother gave it to me.

The CPU is called the Sqrtr (i.e. SQuare RooTeR) because it has the capability to approximate the integer square root of a number. I needed some sort of driver program to work toward, and I chose that one. It's stupid because it's only the \emph{integer} square root of a number bounded by $[0, 255]$, but who cares? It's funny. 

The language it uses is called HANDv8 because it's based on ARMv8, just as your hand is based on your arm. It's not quite ARMv8 because I made some visual changes to the syntax to make it easier to interpret. The changes will become apparent in the next chapter.

\section{Meet the Sqrtr}
The Sqrtr is a simulation of a sequential CPU made for Logisim-evolution.

On a computer, all of your important data is in the data memory. However, doing any meaningful amount of operations directly on data in the RAM is unacceptably slow. We need to load data into the Sqrtr's registers, do all necessary operations there, and them move it back. The Sqrtr has 4 general purpose registers and each has 8 bits of storage (which can hold one addressed portion of RAM data or even an address). We call them \R{0}, \R{1}, \R{2}, and \R{3}. They don't go by \texttt{W} or \texttt{X} because the Sqrtr's registers store bytes, not words or double words. Using \texttt{R} avoids the confusion of whether you should be calling registers \texttt{W} or \texttt{X}, since neither applies.

You can write instructions in HANDv8 to load data into registers from the memory, do operations on them, and send them back to the data memory. You can also use it to start your program with some data already stored in the data memory. The Sqrtr treats all numbers as positive because we don't have the budget for signed arithmetic (remember, it's an 8-bit processor).

The Sqrtr is not pipelined or forwarded, and as such it is purely sequential. It takes one clock cycle to execute one instruction and it only executes one instruction at a time.

\chapter{Programming in HANDv8}
Put your instructions in a \texttt{.s} file under the \header{.text} header if you plan on also having a \header{.data} segment. Otherwise, the interpreter will assume your file only contains instructions. The sections can be in any order, but you cannot have one inside the other. The entire language is case-insensitive but I usually stick to making everything capital except for comments for reasons I don't remember. I will otherwise not prescribe good coding practices because I don't care. To see how the language is best used, check the included demo files.

\section{Instructions}
When instructions take multiple registers as parameters, they can be different or the same. All immediates are unsigned and 8 bits long, where 0 is always valid. Register numbers and immediates must be written in decimal. 
\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries\instruction{DIV} \R{w} \R{a} \imm}]
    \item[\instruction{END}] Ends the program. The interpreter will ignore any instructions after this instruction. This is not necessary as the program terminates at the end of the \header{.text} section anyway, but it lets the interpreter finish slightly faster.
\end{description}

\subsection{Memory Access}
\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries\instruction{STR} \R{t} \R{a} \imm}]
    \item[\instruction{LDR} \R{w} \R{a}] Writes into \R{w} a byte from data memory which is addressed by the content of \R{a}.
    \item[\instruction{LDR} \R{w} \R{a} \R{b}] Writes into \R{w} a byte from data memory which is addressed by the sum of the contents of $\R{a} + \R{b}$.
    \item[\instruction{LDR} \R{w} \R{a} \imm] Writes into \R{w} a byte from data memory which is addressed by the sum of the content of $\R{a} + \imm$.
    \item[\instruction{STR} \R{t} \R{a}] Stores the content of \R{t} into data memory addressed by the contents of \R{a}.
    \item[\instruction{STR} \R{t} \R{a} \imm] Stores the content of \R{t} into data memory addressed by the content of $\R{a} + \imm$.
\end{description}

The syntaxes of \instruction{LDR} and \instruction{STR} with no third argument are shorthand for \instruction{LDR} \R{w} \R{a} \texttt{{\color{imm}0}} and \instruction{STR} \R{t} \R{a} \texttt{{\color{imm}0}}. The first argument of \instruction{STR} is called \R{t} rather than \R{w} to signal that you are not writing to the first register, whereas you are doing so in all other instructions.

\subsection{Arithmetic}
\begin{description}[labelwidth=\widthof{\bfseries\instruction{DIV} \R{w} \R{a} \imm}]
    \item[\instruction{ADD} \R{w} \R{a} \R{b}] Writes into \R{w} the sum of the contents of $\R{a} + \R{b}$.
    \item[\instruction{ADD} \R{w} \R{a} \imm] Writes into \R{w} the sum of the content of $\R{a} + \imm$.
    \item[\instruction{DIV} \R{w} \R{a} \R{b}] Writes into \R{w} the integer quotient $\floor{\frac{\text{\R{a}}}{\text{\R{b}}}}$. If $\R{b} = 0$, then $\R{w} = 0$.
    \item[\instruction{DIV} \R{w} \R{a} \imm] Writes into \R{w} the integer quotient $\floor{\frac{\text{\R{a}}}{\text{\imm}}}$. If $\imm = 0$, then $\R{w} = 0$.
\end{description}

Just like the regular mathematical operations, \instruction{ADD} is commutative while \instruction{DIV} is not. That is, swapping \R{a} and \R{b} in an \instruction{ADD} instruction will produce the same result (though for the interpreter's sake, $\imm$ must always come last). Doing the same for \instruction{DIV} does not necessarily give equal results.

You also cannot do math with two immediate operands. If you've made it this far, you can add or floor divide two numbers on your own before you write the program.

The Sqrtr does not have \instruction{SUB} or \instruction{MUL} or a built-in emulation of either. The implementation of either is left as a challenge to the reader.

You can emulate \instruction{MOV} \R{w} \R{a} by using \instruction{ADD} \R{w} \R{a} \texttt{{\color{imm}0}}. You can also emulate \instruction{MOV} \R{w} $\imm$ in two instructions with \instruction{DIV} \R{w} \R{w} \texttt{\color{imm}0} then \instruction{ADD} \R{w} \R{w} \imm. The interpreter won't translate these for you because it threatened to resign if I added more instructions without increasing its salary.






\section{Data Memory}
You can include a \header{.data} header in your program if you want to have some data for your program to load in. The Sqrtr's data memory only holds 256 bytes because the register can only store 256 different addresses anyway.

You can set one byte of memory as such: 
\begin{quotation}\texttt{{\color{header}.data}\\
    {\color{imm}0xAA} = {\color{imm}0xBB}\\
    {\color{imm}a6} = {\color{imm}ff}
}\end{quotation}

In this case, the value \texttt{{\color{imm}0xBB}} gets written to memory at address \texttt{{\color{imm}0xAA}}. {\bfseries TAKE NOTE} that both values are written in {\bfseries hexadecimal}, whereas immediates in \header{.text} use {\bfseries decimal}. It works this way to make the data memory easier to debug.

You can also use this syntax to set a range of values starting at one address:

\begin{quotation}\texttt{\header{.data}\\
    {\color{imm}0xAA}: {\color{imm}0xNN} {\color{imm}0xNN} ...\\
    {\color{imm}08}: {\color{imm}ff} {\color{imm}ab} {\color{imm}00} {\color{imm}c1}
}\end{quotation}

In this case, each subsequent byte of data, starting with \texttt{{\color{imm}0xAA}} will contain the following arguments. This means address \texttt{{\color{imm}08}} contains \texttt{{\color{imm}ff}}, address \texttt{{\color{imm}09}} contains \texttt{{\color{imm}ab}}, and so on.

If you like, you can mix and match these syntaxes within \header{.data}.
\begin{quotation}\texttt{\header{.data}\\
    {\color{imm}00}: {\color{imm}a0} {\color{imm}a1} {\color{imm}a2} {\color{imm}a3}\\
    {\color{imm}8} = {\color{imm}1}
}\end{quotation}
The above code snippet will have your memory looking as such:
\begin{table}[H]
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
    \hline
    address  & 00 & 01 & 02 & 03 & 04 & 05 & 06 & 07 & 08 & ... \\ \hline
    contents & a0 & a1 & a2 & a3 & 00 & 00 & 00 & 00 & 01 & 00  \\ \hline
    \end{tabular}
\end{table}

Just be aware that if you assign multiple values to the same address, the interpreter will only use whichever one you assign last chronologically.

You may be wondering, "why have two syntaxes if you can do with the colon syntax the same thing you can do with the equals syntax?" My answer is that programmers love needlessly adding specifications to their languages. The equals syntax is exclusively to set \textit{one} memory address. If you add more the interpreter will complain and refuse. The equals syntax keeps you accountable.

\section{Comments}
The interpreter will ignore anything between the characters \texttt{//} and the end of a line, no matter what is on the other side. This works in all sections anywhere in the file. Be careful not to comment out anything you actually need. There are no multiline comments. If you are doing something complicated enough to require multiline comments you should be using a better language on a more expensive CPU.

\section{FAQ}
\subsection{Why does HANDv8 have DIV and not SUB?}
I could only fit one ALUop bit into the machine code. (It'll make more sense in a few pages.) Plus, I'd need to add \textit{two} more operations if I did add another, which is too much freedom for this project. Aside from the required \instruction{ADD}, I chose division because it is a compulsory operation to do what the Sqrtr set out to do, which is calculate the integer square root of an 8-bit number. You can find my implementation of the algorithm in \texttt{sqrt.s}.

The algorithm I settled on is an adaptation of Heron's method. Instead of using $\epsilon$ and checking for accuracy, I just ran the algorithm a bunch and found that for all 8-bit numbers, running the algorithm 4 times computes the correct integer square root. For the nerds: to find $\floor{\sqrt{n}}$, I use the seed guess of $root = \floor{\frac{n}{2}}$ and repeat this approximation 4 times:
\begin{equation*}
    root = \floor{\frac{\floor{\frac{n}{root}} + root}{2}}.
\end{equation*}
Since it's quick enough to brute force, you can check that the final $root$ will always be exactly $\floor{\sqrt{n}}$ for all $n \in [0,255]$.

\subsection{As a mathematician, your \instruction{DIV} vexes me.}
Not a question. Because we are in a world of my creation, I decided to define the famously undefined operation of dividing by 0. I needed a way to zero a register with one operation, so I defined zero-division to do that. It was easy enough to implement the simple conditional of \texttt{if (denominator == 0) then return 0} so I did. I couldn't find any reputable division circuit that did this for me, so I heavily adapted the work of one SDSpivey\footnote{You can find his work at \href{https://github.com/logisim-evolution/logisim-evolution/discussions/1660}{https://github.com/logisim-evolution/logisim-evolution/discussions/1660}.} 
and took out all that nasty electrical engineering stuff.


\chapter{Assembling}
You've got your instructions and your data in a \texttt{.s} file. To get it into the Sqrtr, you'll want to use the interpreter. It will will output Logisim-evolution-ready memory images. 

First, get \texttt{interpreter.py} into the same directory as your file. Run it in Powershell, Batch, or Shell with \texttt{python interpreter.py <yourfile>.s}. You can exclude the \texttt{.s} if you like, but it's good luck to include it. It will output \texttt{<yourfile>-instructions.txt} and \texttt{<yourfile>-data.txt}. If these files already exist, the interpreter will overwrite them.

The interpreter will throw a tantrum and quit if...
\begin{itemize}
    \item you run the interpreter the wrong way. It will remind you of its usage.
    \item you use a bad (misspelled or nonexistent) instruction. It will tell you what the bad instruction is and what line it was on.
    \item you use an invalid syntax. It will tell you what was wrong with it, unless it was so bad it crashes the interpreter entirely.
    \item you use too many instructions. The instruction memory can only fit 256 instructions. You can mod it to hold more, but it will void your warrantee. You can do as much in \header{.data} as you want because it is handled by the interpreter, not the RAM.
    \item you use an immediate anywhere that is not in $[0,255]$. Any number outside of this range cannot be represented by 8 bits of unsigned binary or 2 digits of hexadecimal.
    \item you forget to separate \header{.data} and \header{.text} sections with their respective headers. This has undefined behavior but will most likely cause one of the above messages.
\end{itemize}

The interpreter will complain but continue (assuming no other rules are broken) if...
\begin{itemize}
    \item you use \instruction{END} but have more data after it. It will let you know that you might have prematurely \instruction{END}ed the program, but it won't stop you.
    \item you don't include any labels. It will assume everything is \header{.text} and move on. If it assumes wrong, the interpreter's behavior is undefined.
    \item you only include \header{.data} and no \header{.text}. I don't know why you'd want to, but you can.
\end{itemize}

This is not an exhaustive list, so double-check your code and heed the interpreter's warnings before you email me.



\chapter{Running}
Once you have the Sqrtr open in Logisim-evolution, you can right-click on the \texttt{instructionMemory}, click "Load Image..." and open \texttt{<yourfile>-instructions.txt}. If you have a nontrivial \header{.data} section, follow the same steps to load \texttt{<yourfile>-data.txt} into the \texttt{dataMemory}.

Once you've loaded everything into Logisim-evolution, you can run it however you please. I personally reccomend choosing the poke tool and manually ticking the clock twice for each instruction. You may also use Auto-tick, or you can mash \texttt{Ctrl+T} or \texttt{Ctrl+F9} until the program has completed. Be aware, however, that when the PC reaches the end of the memory, it will overflow and restart the program from the top. 

There's really nothing to do with the data once the program has completed other than look at it with a sense of fatherly, motherly, or otherwise parental pride, so feel free to do that for as long as you need. If you think of something else, let me know.



\chapter{Machine Code}
This is not very important to the programmer, but intimate knowledge of machine code is absolutely vital to fully understanding the Sqrtr. The interpreter translates every instruction into a 2-byte binary number of this form:
\begin{equation*}
    a,b,c,d,ee,ff,gg,hhhhhh.
\end{equation*}
To understand \textit{how} the Sqrtr reads it, we must understand what each segment is.
\begin{enumerate}
    \item The first 4 bits are the instruction's opcode. Each bit is a switch, so each only needs to be one bit.
    \begin{enumerate}
        \item$a$ represents \texttt{ReadToReg}. It is a switch to tell the register file whether it's writing to the register from data memory (1) or from the ALU (0).
        \item $b$ represents \texttt{MemWrite}. It is a switch to tell the CPU whether this instruction involves writing to data memory (1) or a register (0).
        \item $c$ represents \texttt{ALUop}. This switch is 0 to do addition, which is required by all instructions except \instruction{DIV}, and 1 to do division.
        \item $d$ represents \texttt{UseImm}. If 1, the ALU receives the immediate which is stored in bits $gghhhhhh$. If 0, the ALU will receive the contents of the register number stored in bits $gg$. The ALU always receives \texttt{ReadReg1} so there's no switch for it.
    \end{enumerate}
    \item $ee$ is \texttt{WriteReg}. For all syntaxes of all instructions except \instruction{STR}, a register is written to. This is the number of that register, encoded into binary. It needs 2 bits to hold the labels in $[0,4]$. For \instruction{STR}, this is \R{t}, to signal that \R{t} does not get written to.
    \item $ff$ is \texttt{ReadReg1}. For all syntaxes of all instructions, at least one register must be read from. I usually call this \R{a}. This is the number of the mandatory one, encoded into binary. It needs 2 bits to hold the labels in $[0,4]$.
    \item $gg$, if and only if $\text{\texttt{UseImm}} = 0$, is \texttt{ReadReg2}. For some instructions, two registers must be read from. This is the number of the second one, encoded into binary. It needs 2 bits to hold the labels in $[0,4]$. I usually call this \R{b}.
    \item $gghhhhhh$, if and only if $\text{\texttt{UseImm}} = 1$, is the immediate to be used as \imm. While the contents of $hhhhhh$ are irrelevant if $\text{\texttt{UseImm}} = 0$, the interpreter will set them all to 0. Of course, this field needs to be 8 bits as to fit a full \imm.
\end{enumerate}

More specifically, here is what the opcode and layout looks like for each command and their syntaxes:

\setlength\tabcolsep{2pt}
\begin{table}[H]
\begin{tabular}{l|cccccccc}
    Instruction & \texttt{ReadToReg} & \texttt{MemWrite} & \texttt{ALUop} & \texttt{UseImm} & \texttt{WriteReg} & \texttt{ReadReg1} & \texttt{ReadReg2} & \texttt{imm}  \\
    \hline
    \instruction{ADD} \R{w} \R{a} \R{b} & \texttt{0} & \texttt{0} & \texttt{0} & \texttt{0} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & \texttt{0b{\color{register}b}} & - \\
    \instruction{ADD} \R{w} \R{a} \imm  & \texttt{0} & \texttt{0} & \texttt{0} & \texttt{1} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & - & \texttt{0b\imm} \\
    \instruction{DIV} \R{w} \R{a} \R{b} & \texttt{0} & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & \texttt{0b{\color{register}b}} & - \\
    \instruction{DIV} \R{w} \R{a} \imm  & \texttt{0} & \texttt{0} & \texttt{1} & \texttt{1} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & - & \texttt{0b\imm} \\
    \instruction{LDR} \R{w} \R{a} \R{b} & \texttt{1} & \texttt{0} & \texttt{0} & \texttt{0} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & \texttt{0b{\color{register}b}} & - \\
    \instruction{LDR} \R{w} \R{a} \imm  & \texttt{1} & \texttt{0} & \texttt{0} & \texttt{1} & \texttt{0b{\color{register}w}} & \texttt{0b{\color{register}a}} & - & \texttt{0b\imm} \\
    \instruction{STR} \R{t} \R{a} \imm  & \texttt{0} & \texttt{1} & \texttt{0} & \texttt{1} & \texttt{0b{\color{register}t}} & \texttt{0b{\color{register}a}} & - & \texttt{0b\imm}
\end{tabular}
{\small Note: I excluded syntaxes of \instruction{LDR} and \instruction{STR} with no third argument. They are shorthand for their respective $\imm$ syntaxes with $\imm = 0$.}
\end{table}

This construction leaves open the possibility of a 4th secret memory interaction when \texttt{ReadToReg} and \texttt{MemWrite} are both 1, but now is not the time to theorize on something like that.

The interpreter takes the numbers generated by this scheme, translates them into hexadecimal, and then puts them into a format that Logisim-evolution can read. The Sqrtr then translates it back into decimal and sends each bit (or group of bits) where it needs to go. The datapath is near enough to Figure 3.27 in the textbook (with some simplifications and elaborations) that it would patronize the reader if I explained it at length.

%\chapter{Conclusions}
%\epigraph{No one ever said on their deathbed, "Gee, I wish I had spent more time alone with my computer."}{\textit{- Dani Berry}}
%I feel feverish and unwell.


\end{document}